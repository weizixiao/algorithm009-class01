### 学习笔记
### Hash Table
哈希表，也称为散列表，是根据关键码值（key， value）而直接进行访问的数据结构
它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度
这个映射函数叫做散列函数（Hash Function），存放记录的数组叫作哈希表（或散列表）
- 工程实践
    - 电话号码薄
    - 用户信息表
    - 缓存（LRU Cache）
    - 键值对存储（Redis）

```
key: list
=> (l => 108) + (i => 105) + (e => 101) + (s => 115) = 429
```
- hash碰撞
```
就是多个值算出来的key都是一个值
```
    拉链式解决冲突法，就是这个key里面不止存一个数，加一个链表在里面

| 操作()    | 复杂度（Average） | 复杂度（Worst）(hash碰撞很多的情况) |
| --------- | ----------------- | ----------------------------------- |
| search    | O(1)              | O(n)                                |
| insertion | O(1)              | O(n)                                |
| delete    | O(1)              | O(n)                                |

### 实战题目
- 242
- 49

### 树、图

Linked List是特殊化的Tree，Tree是特殊化的Graph

- 树 Tree

    ![](/Users/weizi/Desktop/极客算法/algorithm009-class01/Week_02/tree.png)

    - 遍历Tree，左中后序遍历
        - 前序 （根-左-右）
        - 中序 （左-根-右）
        - 后序 （左-右-根）

    - 二叉搜索树

        二叉搜索树，也称二叉排列树，有序二叉树（Ordered Binary Tree）,排序二叉树，是指一颗空树或者具有下列性质的二叉树

        - 左子树上所有节点的值均小于它的根节点的值
        - 右子树上所有节点的值均大于它的根节点的值
        - 依此类推：左、右树分别为二叉查找树

        中序遍历：升序排列

        | 操作   | 复杂度(正常) | 复杂度（退化链表） |
        | ------ | ------------ | ------------------ |
        | search | O(logn)      | O(n)               |
        | insert | O(logn)      | O(n)               |
        | delete | O(logn)      | O(n)               |

        

- 图Graph

  ![](/Users/weizi/Desktop/极客算法/algorithm009-class01/Week_02/图.png)


##### 题目
- 94

### 堆、二叉堆
- 堆
    Heap：可以迅速找到一堆数中的最大或者最小值的数据结构
    将根节点最大的堆叫做大顶堆或大根堆，根节点最小的堆叫做小顶堆或小根堆，常见的堆有二叉堆、斐波那契堆等
    假设是大顶堆，则常见操作（API）：
    find-max:       O(1)
    delete-max:     O(logN)
    insert(create): O(logN) or O(1)
    不同实现比较：https://en.wikipedia.org/wiki/Heap_(data_structure)

    - 二叉堆
        - 通过完全二叉树来实现（注意：不是二叉搜索树）
        - 二叉堆（大顶）它满足下列性质
            - 1、是一颗完全树
            - 2、树中任意节点的值总是 >= 其子节点的值
        - 二叉堆实现细节
            - 1、二叉堆一般都通过“数组”实现
            - 2、假如“第一个元素”在数组中的索引为0的话，则父节点和子节点的位置关系如下：
            - (01)索引为i的左孩子的索引是(2*i+1);
            - (02)索引为i的左孩子的索引是(2*i+2);
            - (03)索引为i的父孩子的索引是floor((i-1)/2);
        - insert插入操作
            - 新元素一律先插入到堆的尾部
            - 依次向上调整整个堆的结构（一直到根即可）
        - Delete Max 删除堆顶操作
            - 将尾堆元素替换到顶部（即堆顶被替换删除掉）
            - 依次从根部向下调整整个堆的结构（一直到尾堆即可）

**注意：二叉堆是堆（优先队列priority_queue）的一种常见且简单的实现；但是并不是最优的实现。**

| 操作         | 复杂度  |
| ------------ | ------- |
| find-min     | O(1)    |
| delete-min   | O(1)    |
| insert       | O(logN) |
| dearease-key | O(logN) |

#### 实战
- 40


### 图
- Graph（V，E）
- V-vertex：点
    - 度 - 入度和出度
    - 点与点之间：连通与否
- E - edge：边
    - 有向和无向（单行线）
    - 权重（边长）

![](/Users/weizi/Desktop/极客算法/algorithm009-class01/Week_02/ 有向无权图.png)